param(
    [Parameter(Mandatory = $true)]
    [string]$SourcePath,
    [string]$OutFile = "",
    [switch]$Stdout
)

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

if ($Stdout -and -not [string]::IsNullOrWhiteSpace($OutFile)) {
    throw "Cannot combine --stdout and --out."
}

$scriptDir = Split-Path -Parent $PSCommandPath
$parser = Join-Path $scriptDir "parse_main_exit.ps1"
$exitCode = [int](& $parser -SourcePath $SourcePath)

$sourceFull = [System.IO.Path]::GetFullPath($SourcePath)
$sourceName = [System.IO.Path]::GetFileName($sourceFull)

$doc = @"
# Stage0 Source Documentation

## File

- path: $sourceFull
- name: $sourceName

## Entry Point

### fn main()

- behavior: invokes Linux sys_exit
- stage0 exit code: $exitCode

## Notes

- Generated by fin doc stage0 subset.
- Current grammar subset: fn main() [-> u8] { let/var/assign/exit } with u8 literals, identifier expressions, stage0 bootstrap `ok/err/try` forms, and optional `: u8` binding annotations.
"@

if ($Stdout) {
    Write-Output $doc
    exit 0
}

if ([string]::IsNullOrWhiteSpace($OutFile)) {
    $sourceDir = Split-Path -Parent $sourceFull
    $docsDir = Join-Path $sourceDir "..\\docs"
    $base = [System.IO.Path]::GetFileNameWithoutExtension($sourceName)
    $OutFile = Join-Path $docsDir "$base.md"
}

$outFull = [System.IO.Path]::GetFullPath($OutFile)
$outDir = Split-Path -Parent $outFull
if (-not (Test-Path $outDir)) {
    New-Item -ItemType Directory -Path $outDir -Force | Out-Null
}

Set-Content -Path $outFull -Value $doc -NoNewline
Write-Host ("doc_written={0}" -f $outFull)
